<img src="https://upload.wikimedia.org/wikipedia/commons/f/fc/UPC_logo_transparente.png" width="150" alt="UPC Logo">

# Universidad Peruana de Ciencias Aplicadas

### **CURSO:** Desarrollo de Aplicaciones Open Source

### **NRC**: 4334

### **Profesor:** Hugo Allan Mori Paiva

### **Ingenier칤a de software**

## Informe de Trabajo Final

### **Nombre del startup:** APX-01

### **Nombre del producto:** EduHive

## **Integrantes**


| **Nombre**                             | **Codigo** |
| -------------------------------------- | ---------- |
| **Alejo Cardenas Jose Antonio**        | U202122484 |
| **Luquillas Asto Omar**                | U20211G641 |
| **Real Calder칩n Sebasti치n Omar**     | U20221D964 |
| **Flores Apaico Josue Antonio**        | U20201F773 |
| **Mendoza Vergara Franklin Alejandro** | U202312343 |

Abril 2025

## Registro de Versiones del Informe


| Versi칩n | Fecha | Autor | Descripci칩n de modificaci칩n |
| -------- | ----- | ----- | ----------------------------- |

## Project Report Collaboration Insights

## Contenido

- [Student Outcome](#student-outcome)
- [Objetivos SMART](#objetivos-smart)
- [Cap칤tulo I](#cap칤tulo-i)
  - [1.1. Startup Profile](#11-startup-profile)
    - [1.1.1. Descripci칩n de la Startup](#111-descripci칩n-de-la-startup)
    - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
  - [1.2. Solution Profile](#12-solution-profile)
    - [1.2.1. Antecedentes y problem치tica](#121-antecedentes-y-problem치tica)
    - [1.2.2. Lean UX Process](#122-lean-ux-process)
      - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
      - [1.2.2.2. Lean UX Assumptions](#1222-lean-ux-assumptions)
      - [1.2.2.3. Lean UX Hypothesis Statements](#1223-lean-ux-hypothesis-statements)
      - [1.2.2.4. Lean UX Canvas](#1224-lean-ux-canvas)
  - [1.3. Segmentos Objetivo](#13-segmentos-objetivo)
- [Cap칤tulo II: Requirements Elicitation & Analysis](#cap칤tulo-ii-requirements-elicitation--analysis)
  - [2.1. Competidores](#21-competidores)
    - [2.1.1. An치lisis competitivo](#211-an치lisis-competitivo)
    - [2.1.2. Estrategias y t치cticas frente a competidores](#212-estrategias-y-t치cticas-frente-a-competidores)
  - [2.2. Entrevistas](#22-entrevistas)
    - [2.2.1. Dise침o de entrevistas](#221-dise침o-de-entrevistas)
    - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
    - [2.2.3. An치lisis de entrevistas](#223-an치lisis-de-entrevistas)
  - [2.3. Needfinding](#23-needfinding)
    - [2.3.1. User Personas](#231-user-personas)
    - [2.3.2. User Task Matrix](#232-user-task-matrix)
    - [2.3.3. User Journey Mapping](#233-user-journey-mapping)
    - [2.3.4. Empathy Mapping](#234-empathy-mapping)
    - [2.3.5. As-is Scenario Mapping](#235-as-is-scenario-mapping)
  - [2.4. Ubiquitous Language](#24-ubiquitous-language)
- [Cap칤tulo III: Requirements specification](#cap칤tulo-iii-requirements-specification)
  - [3.1. To-Be Scenario Mapping](#31-to-be-scenario-mapping)
  - [3.2. User Stories](#32-user-stories)
  - [3.3. Impact Mapping](#33-impact-mapping)
  - [3.4. Product Backlog](#34-product-backlog)
- [Cap칤tulo IV: Product Design](#cap칤tulo-iv-product-design)
  - [4.1. Style Guidelines](#41-style-guidelines)
    - [4.1.1. General Style Guidelines](#411-general-style-guidelines)
    - [4.1.2. Web Style Guidelines](#412-web-style-guidelines)
  - [4.2. Information Architecture](#42-information-architecture)
    - [4.2.1. Organization Systems](#421-organization-systems)
    - [4.2.2 Labeling Systems](#422-labeling-systems)
    - [4.2.3 SEO Tags and Meta Tags](#423-seo-tags-and-meta-tags)
    - [4.2.4. Searching Systems](#424-searching-systems)
    - [4.2.5. Navigation Systems](#425-navigation-systems)
  - [4.3. Landing Page UI Design](#43-landing-page-ui-design)
    - [4.3.1. Landing Page Wireframe](#431-landing-page-wireframe)
    - [4.3.2. Landing Page Mock-up](#432-landing-page-mock-up)
  - [4.4. Web Applications UX/UI Design](#44-web-applications-uxui-design)
    - [4.4.1. Web Applications Wireframes](#441-web-applications-wireframes)
    - [4.4.2. Web Applications Wireflow Diagrams](#442-web-applications-wireflow-diagrams)
    - [4.4.2. Web Applications Mock-ups](#442-web-applications-mock-ups)
    - [4.4.3. Web Applications User Flow Diagrams](#443-web-applications-user-flow-diagrams)
  - [4.5. Web Applications Prototyping](#45-web-applications-prototyping)
  - [4.6. Domain-Driven Software Architecture](#46-domain-driven-software-architecture)
    - [4.6.1. Software Architecture Context Diagram](#461-software-architecture-context-diagram)
    - [4.6.2. Software Architecture Container Diagrams](#462-software-architecture-container-diagrams)
    - [4.6.3. Software Architecture Components Diagrams](#463-software-architecture-components-diagrams)
  - [4.7. Software Object-Oriented Design](#47-software-object-oriented-design)
    - [4.7.1. Class Diagrams](#471-class-diagrams)
    - [4.7.2. Class Dictionary](#472-class-dictionary)
  - [4.8. Database Design](#48-database-design)
    - [4.8.1. Database Diagram](#481-database-diagram)
- [Cap칤tulo V: Product Implementation, Validation & Deployment](#cap칤tulo-v-product-implementation-validation--deployment)
  - [5.1. Software Configuration Management](#51-software-configuration-management)
    - [5.1.1. Software Development Environment Configuration](#511-software-development-environment-configuration)
    - [5.1.2. Source Code Management](#512-source-code-management)
    - [5.1.3. Source Code Style Guide & Conventions](#513-source-code-style-guide--conventions)
    - [5.1.4. Software Deployment Configuration](#514-software-deployment-configuration)
  - [5.2. Landing Page, Services & Applications Implementation](#52-landing-page-services--applications-implementation)
    - [5.2.1. Sprint 1](#521-sprint-1)
      - [5.2.1.1. Sprint Planning 1](#5211-sprint-planning-1)
      - [5.2.1.2. Aspect Leaders and Collaborators](#5212-aspect-leaders-and-collaborators)
      - [5.2.1.3. Sprint Backlog 1](#5213-sprint-backlog-1)
      - [5.2.1.4. Development Evidence for Sprint Review](#5214-development-evidence-for-sprint-review)
      - [5.2.1.5. Execution Evidence for Sprint Review](#5215-execution-evidence-for-sprint-review)
      - [5.2.1.6. Services Documentation Evidence for Sprint Review](#5216-services-documentation-evidence-for-sprint-review)
      - [5.2.1.7. Software Deployment Evidence for Sprint Review](#5217-software-deployment-evidence-for-sprint-review)
      - [5.2.1.8. Team Collaboration Insights during Sprint](#5218-team-collaboration-insights-during-sprint)
  - [5.3. Validation Interviews](#53-validation-interviews)
    - [5.3.1. Dise침o de entrevistas](#531-dise침o-de-entrevistas)
    - [5.3.2. Registro de entrevistas](#532-registro-de-entrevistas)
    - [5.3.3. Evaluaciones seg칰n heur칤sticas](#533-evaluaciones-seg칰n-heur칤sticas)
  - [5.4. Video About-the-Product](#54-video-about-the-product)
- [Conclusiones](#conclusiones)
- [Bibliograf칤a](#bibliograf칤a)
- [Anexos](#anexos)

## Student Outcome

## Objetivos SMART

## Capitulo I

### 1.1. Startup Profile

#### 1.1.1. Descripci칩n de la Startup

#### 1.1.2. Perfiles de integrantes del equipo

### 1.2. Solution Profile

#### 1.2.1. Antecedentes y problem치tica

#### 1.2.2. Lean UX Process

##### 1.2.2.1. Lean UX Problem Statements

##### 1.2.2.2. Lean UX Assumptions

##### 1.2.2.3. Lean UX Hypothesis Statements

##### 1.2.2.4. Lean UX Canvas

### 1.3. Segmentos Objetivo

## Cap칤tulo II: Requirements Elicitation & Analysis

### 2.1. Competidores

#### 2.1.1. An치lisis competitivo

#### 2.1.2. Estrategias y t치cticas frente a competidores

### 2.2. Entrevistas

#### 2.2.1. Dise침o de entrevistas

#### 2.2.2. Registro de entrevistas

#### 2.2.3. An치lisis de entrevistas

### 2.3. Needfinding

#### 2.3.1. User Personas

#### 2.3.2. User Task Matrix

#### 2.3.3. User Journey Mapping

#### 2.3.4. Empathy Mapping

#### 2.3.5. As-is Scenario Mapping

### 2.4. Ubiquitous Language

## Cap칤tulo III: Requirements specification

### 3.1. To-Be Scenario Mapping

### 3.2. User Stories

### 3.3. Impact Mapping

### 3.4. Product Backlog

## Cap칤tulo IV: Product Design

### 4.1. Style Guidelines

#### 4.1.1. General Style Guidelines

#### 4.1.2. Web Style Guidelines

### 4.2. Information Architecture

#### 4.2.1. Organization Systems

#### 4.2.2 Labeling Systems

#### 4.2.3 SEO Tags and Meta Tags

#### 4.2.4. Searching Systems

#### 4.2.5. Navigation Systems

### 4.3.  Landing Page UI Design.

#### 4.3.1. Landing Page Wireframe.

#### 4.3.2. Landing Page Mock-up.

### 4.4.  Web Applications UX/UI Design.

#### 4.4.1. Web Applications Wireframes

#### 4.4.2. Web Applications Wireflow Diagrams

#### 4.4.2. Web Applications Mock-ups

#### 4.4.3. Web Applications User Flow Diagrams

### 4.5.  Web Applications Prototyping

### 4.6.  Domain-Driven Software Architecture

#### 4.6.1. Software Architecture Context Diagram

#### 4.6.2. Software Architecture Container Diagrams

#### 4.6.3. Software Architecture Components Diagrams

### 4.7.  Software Object-Oriented Design

#### 4.7.1. Class Diagrams

#### 4.7.2. Class Dictionary

### 4.8.  Database Design

#### 4.8.1. Database Diagram

## Cap칤tulo V: Product Implementation, Validation & Deployment

### 5.1. Software Configuration Management

#### 5.1.1. Software Development Environment Configuration

Antes de comenzar, es importante definir claramente los requisitos de  la p치gina web. Esto incluye las funcionalidades que se desean ofrecer  en nuestra plataforma.

* Project Management:

  * Trello
    Prop칩sito de Uso: Gesti칩n de tareas del equipo, seguimiento de actividades y organizaci칩n del flujo de trabajo del proyecto.
    Ruta de Referencia/Descarga: [Trello](https://trello.com) (SaaS)

  <img src="./images/chapter-5/trello.png" alt="Trello" width="400"/>
* Requirements Management:

  * Google Docs

    Prop칩sito de Uso: Redactar y compartir la documentaci칩n de requisitos funcionales y no funcionales del proyecto, permitiendo colaboraci칩n en tiempo real entre los miembros del equipo.
    Ruta de Referencia/Descarga: [Google Docs](https://docs.google.com) (SaaS)

    <img src="./images/chapter-5/googleDocs.png" alt="Google Docs" width="400"/>
* Product UX/UI Design:

  * Figma

    Prop칩sito de Uso: Dise침o de wireframes, prototipos navegables y diagramas de flujo de pantallas (wireflows).
    Ruta de Referencia/Descarga: [Figma](https://www.figma.com) (SaaS)

    <img src="./images/chapter-5/figma.png" alt="Figma" width="400"/>
* Software Development:

  * GitHub (con GitFlow)

    Prop칩sito de Uso: Control de versiones, colaboraci칩n entre desarrolladores, organizaci칩n mediante ramas y almacenamiento del c칩digo y documentaci칩n.
    Ruta de Referencia/Descarga: [GitHub](https://github.com) (SaaS)

    <img src="./images/chapter-5/gitHub.png" alt="Git Hub" width="400"/>
  * WebStorm IDE

    Prop칩sito de Uso: Edici칩n del c칩digo fuente del proyecto.
    Ruta de Referencia/Descarga: [WebStorm IDE](https://www.jetbrains.com/webstorm/) (SaaS)

    <img src="./images/chapter-5/webStorm.png" alt="Web Storm" width="400"/>
  * Postman:

    Prop칩sito de Uso: Pruebas de APIs para verificar peticiones, respuestas y funcionamiento de los endpoints.
    Ruta de Referencia/Descarga: [Postman](https://www.postman.com/downloads/) (SaaS)

    <img src="./images/chapter-5/postman.png" alt="Postman" width="400"/>


* Software Deployment:

  * Firebase

    Prop칩sito de Uso: Plataforma utilizada para el despliegue y alojamiento del producto digital, as칤 como servicios backend como base de datos, autenticaci칩n y funciones en la nube.
    Ruta de Referencia/Descarga: [Fire Base](https://firebase.google.com) (SaaS)

    <img src="./images/chapter-5/fireBase.png" alt="Firebase" width="400"/>
  * GitHub Page

    Prop칩sito de Uso: Despliegue de la landing page del proyecto, permitiendo su visualizaci칩n p칰blica desde el repositorio.
    Ruta de Referencia/Descarga: [GitHub Actions](https://pages.github.com) (SaaS)

    <img src="./images/chapter-5/gitHubPages.png" alt="Github Pages" width="300"/>
  * Microsoft Azure

    Prop칩sito de Uso: Plataforma para el despliegue del backend del sistema, incluyendo servicios como API hosting, bases de datos y autenticaci칩n.
    Ruta de Referencia/Descarga: [Microsoft Azure](https://azure.microsoft.com) (SaaS)

    <img src="./images/chapter-5/microsoftAzure.png" alt="Microsoft Azure" width="400"/>
* Software Documentation:

  * Git Hub
    Prop칩sito de Uso: Almacenamiento, versionado y colaboraci칩n en la documentaci칩n del proyecto, as칤 como la gesti칩n del repositorio que contiene la documentaci칩n.
    Ruta de Referencia/Descarga: [Git Hub](https://github.com) (SaaS)

    <img src="./images/chapter-5/gitHub.png" alt="Git Hub" width="400"/>
  * Web Storm IDE
    Prop칩sito de Uso: Edici칩n de archivos Markdown y documentaci칩n t칠cnica relacionada al proyecto. Se utiliza para estructurar y organizar la documentaci칩n de forma eficiente.
    Ruta de Referencia/Descarga: [Web Storm IDE](https://www.jetbrains.com/webstorm/) (SaaS)

  <img src="./images/chapter-5/webStorm.png" alt="Web Storm IDE" width="400"/>

  Con esta configuraci칩n, nuestro equipo puede colaborar de manera  eficiente y gestionar el ciclo de vida completo del desarrollo del  producto digital, desde la planificaci칩n hasta el despliegue y  mantenimiento.

#### 5.1.2. Source Code Management

En esta secci칩n, nuestro equipo establece los medios y el esquema de  organizaci칩n que aplicar치 para el seguimiento de modificaciones  utilizando GitHub como plataforma y sistema de control de versiones.  De esta manera, configuramos un repositorio remoto en GitHub para  almacenar el c칩digo fuente y colaborar con los compa침eros del grupo.


* Plataforma de control de versiones:
  De esta manera, configuramos un repositorio remoto en GitHub para  almacenar el c칩digo fuente y colaborar con los compa침eros del grupo.  Los URLs de los repositorios son los siguientes:

  * Landing Page : [Landing Page](https://github.com/APX-01/Landing-Page)
  * Frontend Web Applications : [Frontend Web Applications](https://github.com/APX-01/Frontend-Web-Applications)
  * Backend Web Services : [Backend Web Services](https://github.com/APX-01/Backend-Web-Services)
* Implementaci칩n de GitFlow:
  Organizamos el repositorio en ramas para diferentes entornos.

  * Ramas base:

    - Main branch (rama principal): Contiene la versi칩n de producci칩n.
    - Develop branch: Contiene el c칩digo en desarrollo, que eventualmente  ser치 fusionado en la rama principal.
  * Feature branches:

    * Feature branch:

      Para cada funcionalidad nueva se crea una rama desde develop.Convenci칩n para el nombre: `feature/nombre-corto-descriptivo`
  * Release branches:

    - Release branch:

      Se crean cuando el proyecto est치 listo para pasar a producci칩n, desde develop.
      Convenci칩n: `release/x.y.z` (usando versionado sem치ntico)
  * Hotfix branches:

    * Hotfix branch:

      Se crean desde `main` para corregir errores cr칤ticos en producci칩n.
      Convenci칩n: `hotfix/x.y.z`
* Versionado sem치ntico (Semantic Versioning)

  - Semantic Versioning Format:

    Aplicamos semantic versioning para nombrar nuestras releases siguiendo  el esquema MAJOR.MINOR.PATCH

    <table border="1" cellspacing="0" cellpadding="8">
      <thead>
        <tr>
          <th>Parte</th>
          <th>Significado</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>MAJOR</strong></td>
          <td>Cambios importantes que rompen la compatibilidad con versiones anteriores (por ejemplo, eliminas funciones o cambias APIs que otros ya usaban).</td>
        </tr>
        <tr>
          <td><strong>MINOR</strong></td>
          <td>A침ades nuevas funcionalidades de forma compatible (sin romper lo que ya funciona).</td>
        </tr>
        <tr>
          <td><strong>PATCH</strong></td>
          <td>Solucionas errores o bugs, sin agregar nuevas funciones ni romper nada.</td>
        </tr>
      </tbody>
    </table>
* Mensajes de commit con Conventional Commits

  Utilizamos Conventional Commits para los mensajes en nuestros commits. Usando el siguiente template:

  `<tipo>(<opcional-alcance>): <mensaje>`

  - Tipos:

  `feat`: nueva funcionalidad

  `fix`: correcci칩n de errores

  `docs`: cambios en la documentaci칩n

  `style`: cambios de estilo/formato (sin afectar funcionalidad)

  `refactor`: reestructuraci칩n del c칩digo (sin cambios funcionales)

  `test`: a침adir o modificar pruebas

  `chore`: tareas de mantenimiento

  * Ejemplos:

    feat(auth): Added auth

    fix(landing): fix landing header


#### 5.1.3. Source Code Style Guide & Conventions

El equipo ha definido las siguientes convenciones de nombres y estilos de codificaci칩n, aplicadas en los lenguajes **HTML, CSS, JavaScript, TypeScript y Java**. Todas las nomenclaturas est치n en **ingl칠s**, buscando claridad, estandarizaci칩n y buenas pr치cticas de desarrollo. Se han adoptado gu칤as de estilo reconocidas y actualizadas para cada tecnolog칤a.

---

## 游 HTML

- **Gu칤a adoptada**: [W3C HTML Style Guide](https://www.w3.org/TR/html5/)
- **Nomenclatura y convenciones**:
  - Min칰sculas para etiquetas y atributos: `<div class="container">`
  - Indentaci칩n: 2 espacios.
  - Atributos entre comillas dobles: `<img src="logo.png" alt="Company Logo">`
  - Uso sem치ntico de etiquetas: `<header>`, `<section>`, `<footer>`
  - Comentarios HTML: `<!-- This is a comment -->`

---

## 游댯 CSS

- **Gu칤a adoptada**: [Google HTML/CSS Style Guide](https://google.github.io/styleguide/htmlcssguide.html)
- **Nomenclatura y convenciones**:
  - `kebab-case` para clases e IDs:
    Ejemplo: `.main-header`, `#footer-section`
  - Agrupaci칩n de estilos por componente.
  - Evitar `!important` a menos que sea necesario.
  - Indentaci칩n: 2 espacios.

---

## 游리 JavaScript

- **Gu칤a adoptada**: [Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html)
- **Nomenclatura y convenciones**:
  - `camelCase` para variables y funciones:
    Ejemplo: `let userName = 'Jos칠';`, `function calculateTotal() {}`
  - `PascalCase` para clases:
    Ejemplo: `class ShoppingCart { }`
  - Evitar `snake_case`.
  - Usar `const` y `let` en lugar de `var`.
  - Comentarios:
    - L칤nea: `// Get user info`
    - Bloque:
      ```js
      /**
       * Calculates total price with tax.
       */
      function calculateTotal() {}
      ```

---

## 游릭 TypeScript

- **Gu칤a adoptada**: [Google TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html)
- **Nomenclatura y convenciones**:
  - `camelCase` para variables, funciones y propiedades:
    Ejemplo: `let isActive: boolean = true;`, `function getUserData() {}`
  - `PascalCase` para clases, interfaces, enums y tipos:
    Ejemplo: `class ProductItem {}`, `interface UserDTO {}`, `enum Status { Active, Inactive }`
  - Tipado estricto (`strict: true`) habilitado.
  - Interfaces nombradas con sufijo `DTO` o `Props`.
  - Uso de modificadores `readonly`, `private`, `public`.

---

## 游댮 Java

- **Gu칤a adoptada**: [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)
- **Nomenclatura y convenciones**:
  - `PascalCase` para clases:
    Ejemplo: `public class OrderService {}`
  - `camelCase` para variables, m칠todos y atributos:
    Ejemplo: `int totalAmount;`, `calculateTotalPrice();`
  - Constantes en MAY칔SCULAS con `snake_case`:
    Ejemplo: `public static final int MAX_USERS = 100;`
  - Comentarios tipo Javadoc:
    ```java
    /**
     * Gets the total price of all items.
     * @return total price
     */
    public double getTotalPrice() {}
    ```
  - Paquetes en min칰sculas separados por punto:
    Ejemplo: `com.project.backend.controller`


Adicionalmente hemos considerado tener convenciones para los siguientes apartados:


## 游 Gherkin Conventions for Readable Specifications

- **Gu칤a adoptada**: [Gherkin Syntax and Conventions](https://cucumber.io/docs/gherkin/reference/)
- **Nomenclatura y convenciones**:
  - **Estructura**:
    - **Given**: Define el contexto o el estado inicial.
    - **When**: Define la acci칩n o evento que ocurre.
    - **Then**: Define el resultado o la expectativa despu칠s de la acci칩n.
  - Ejemplo:
    ```gherkin
    Feature: User login
      Scenario: Successful login with valid credentials
        Given the user is on the login page
        When the user enters valid credentials
        Then the user should be redirected to the dashboard
    ```
  - **Uso de tablas** para datos:
    Ejemplo:
    ```gherkin
    Given the following users exist:
      | username | password |
      | user1    | pass123  |
      | user2    | pass456  |
    ```

---

## 游댯 Angular Coding Style Guide

- **Gu칤a adoptada**: [Angular Style Guide](https://angular.io/guide/styleguide)
- **Nomenclatura y convenciones**:
  - **Estructura de carpetas**:
    - `app/` para componentes, servicios y m칩dulos.
    - `assets/` para im치genes, fuentes y otros recursos.
  - **Nombres de clases**: `PascalCase` para componentes, servicios y directivas.
    Ejemplo: `export class UserProfileComponent { }`
  - **Componentes Standalone**: Usar `standalone: true` en la declaraci칩n de `@Component`.
  - **Indentaci칩n**: 2 espacios.
  - **Uso de `trackBy` en `*ngFor`**: Para mejorar el rendimiento al iterar sobre listas grandes.
  - **Servicios**: `camelCase` para nombres de funciones y m칠todos.

---

## 游리 Spring Boot Features

- **Gu칤a adoptada**: [Spring Boot Features](https://spring.io/projects/spring-boot)
- **Nomenclatura y convenciones**:
  - **Paquetes**: El paquete ra칤z debe ser el nombre del proyecto, seguido de subpaquetes para organizaci칩n.
    Ejemplo: `com.projectname.backend`
  - **Clases y m칠todos**: Usar `PascalCase` para clases y `camelCase` para m칠todos y variables.
  - **Configuraci칩n**: Usar `@Value` para inyectar propiedades desde archivos `application.properties`.
  - **Controladores**:
    Ejemplo:
    ```java
    @RestController
    @RequestMapping("/api/users")
    public class UserController {
      @GetMapping("/{id}")
      public ResponseEntity<User> getUser(@PathVariable Long id) {
        // Logic
      }
    }
    ```
  - **Logging**: Usar `@Slf4j` para la integraci칩n de `SLF4J` en clases de servicios y controladores.


#### 5.1.4. Software Deployment Configuration

### 5.2. Landing Page, Services & Applications Implementation.

#### 5.2.1. Sprint 1

##### 5.2.1.1. Sprint Planning 1

##### 5.2.1.2. Aspect Leaders and Collaborators

##### 5.2.1.3. Sprint Backlog 1

##### 5.2.1.4. Development Evidence for Sprint Review

##### 5.2.1.5. Execution Evidence for Sprint Review

##### 5.2.1.6. Services Documentation Evidence for Sprint Review

##### 5.2.1.7. Software Deployment Evidence for Sprint Review

##### 5.2.1.8. Team Collaboration Insights during Sprint

### 5.3. Validation Interviews

#### 5.3.1. Dise침o de entrevistas

#### 5.3.2. Registro de entrevistas

#### 5.3.3. Evaluaciones seg칰n heur칤sticas

### 5.4. Video About-the-Product

## Conclusiones

## Bibliograf칤a

## Anexos
